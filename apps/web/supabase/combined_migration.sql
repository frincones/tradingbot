/*
 * ============================================================================
 * TRADINGBOT SCHEMA v1.0
 * Agentic AI Trading Platform
 * ============================================================================
 */

-- ============================================================================
-- SECTION 1: ENUM TYPES
-- ============================================================================

CREATE TYPE public.strategy_mode AS ENUM ('paper', 'live', 'disabled');
CREATE TYPE public.setup_type AS ENUM ('LONG', 'SHORT', 'NONE');
CREATE TYPE public.intent_status AS ENUM ('pending', 'approved', 'rejected', 'executed', 'cancelled', 'expired');
CREATE TYPE public.order_status AS ENUM ('pending', 'submitted', 'accepted', 'filled', 'partially_filled', 'cancelled', 'rejected', 'expired');
CREATE TYPE public.order_type AS ENUM ('market', 'limit', 'stop_limit');
CREATE TYPE public.order_side AS ENUM ('buy', 'sell');
CREATE TYPE public.time_in_force AS ENUM ('gtc', 'ioc', 'day', 'fok');
CREATE TYPE public.risk_severity AS ENUM ('info', 'warning', 'critical', 'fatal');
CREATE TYPE public.whale_status AS ENUM ('active', 'inactive', 'archived');
CREATE TYPE public.strategy_state AS ENUM ('IDLE', 'SETUP', 'TRIGGERED', 'ORDERING', 'IN_POSITION', 'EXITING', 'COOLDOWN');

-- ============================================================================
-- SECTION 2: STRATEGIES
-- ============================================================================

CREATE TABLE public.strategies (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  name VARCHAR(100) NOT NULL,
  description TEXT,
  enabled BOOLEAN NOT NULL DEFAULT false,
  mode strategy_mode NOT NULL DEFAULT 'paper',
  symbol VARCHAR(20) NOT NULL DEFAULT 'BTC/USD',
  current_state strategy_state NOT NULL DEFAULT 'IDLE',
  state_updated_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(user_id, name)
);

COMMENT ON TABLE public.strategies IS 'Trading strategies configuration';

-- ============================================================================
-- SECTION 3: STRATEGY VERSIONS
-- ============================================================================

CREATE TABLE public.strategy_versions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  strategy_id UUID NOT NULL REFERENCES public.strategies(id) ON DELETE CASCADE,
  version INTEGER NOT NULL,
  config_json JSONB NOT NULL DEFAULT '{}'::jsonb,
  is_active BOOLEAN NOT NULL DEFAULT false,
  notes TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_by UUID REFERENCES auth.users(id),
  UNIQUE(strategy_id, version)
);

COMMENT ON TABLE public.strategy_versions IS 'Strategy configuration versions history';
COMMENT ON COLUMN public.strategy_versions.config_json IS 'JSON config with entry, exit, execution, risk settings';

-- ============================================================================
-- SECTION 4: SIGNALS
-- ============================================================================

CREATE TABLE public.signals (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  strategy_id UUID NOT NULL REFERENCES public.strategies(id) ON DELETE CASCADE,
  ts TIMESTAMPTZ NOT NULL DEFAULT now(),
  setup setup_type NOT NULL,
  scores_json JSONB NOT NULL DEFAULT '{}'::jsonb,
  confirmations_json JSONB NOT NULL DEFAULT '{}'::jsonb,
  levels_json JSONB NOT NULL DEFAULT '{}'::jsonb,
  raw_data_ref TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_signals_strategy_ts ON public.signals(strategy_id, ts DESC);

COMMENT ON TABLE public.signals IS 'Trading signals generated by the feature engine';

-- ============================================================================
-- SECTION 5: TRADE INTENTS
-- ============================================================================

CREATE TABLE public.trade_intents (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  strategy_id UUID NOT NULL REFERENCES public.strategies(id) ON DELETE CASCADE,
  signal_id UUID REFERENCES public.signals(id),
  side order_side NOT NULL,
  qty_usd DECIMAL(18, 2) NOT NULL,
  intended_price DECIMAL(18, 8),
  status intent_status NOT NULL DEFAULT 'pending',
  risk_decision JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  approved_at TIMESTAMPTZ,
  executed_at TIMESTAMPTZ,
  cancelled_at TIMESTAMPTZ,
  expires_at TIMESTAMPTZ,
  idempotency_key VARCHAR(100) UNIQUE
);

CREATE INDEX idx_intents_strategy ON public.trade_intents(strategy_id, created_at DESC);
CREATE INDEX idx_intents_status ON public.trade_intents(status) WHERE status IN ('pending', 'approved');

COMMENT ON TABLE public.trade_intents IS 'Trade intentions before execution, validated by risk engine';

-- ============================================================================
-- SECTION 6: ORDERS
-- ============================================================================

CREATE TABLE public.orders (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  intent_id UUID NOT NULL REFERENCES public.trade_intents(id),
  strategy_id UUID NOT NULL REFERENCES public.strategies(id) ON DELETE CASCADE,
  alpaca_order_id VARCHAR(100) UNIQUE,
  client_order_id VARCHAR(100) UNIQUE NOT NULL,
  symbol VARCHAR(20) NOT NULL DEFAULT 'BTC/USD',
  side order_side NOT NULL,
  order_type order_type NOT NULL,
  qty DECIMAL(18, 8) NOT NULL,
  limit_price DECIMAL(18, 8),
  stop_price DECIMAL(18, 8),
  time_in_force time_in_force NOT NULL DEFAULT 'gtc',
  status order_status NOT NULL DEFAULT 'pending',
  filled_qty DECIMAL(18, 8) DEFAULT 0,
  filled_avg_price DECIMAL(18, 8),
  is_paper BOOLEAN NOT NULL DEFAULT true,
  raw_request JSONB,
  raw_response JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  submitted_at TIMESTAMPTZ,
  filled_at TIMESTAMPTZ,
  cancelled_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_orders_strategy ON public.orders(strategy_id, created_at DESC);
CREATE INDEX idx_orders_status ON public.orders(status) WHERE status NOT IN ('filled', 'cancelled', 'rejected');
CREATE INDEX idx_orders_intent_status ON public.orders(intent_id, status);

COMMENT ON TABLE public.orders IS 'Orders sent to Alpaca trading API';

-- ============================================================================
-- SECTION 7: FILLS
-- ============================================================================

CREATE TABLE public.fills (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  order_id UUID NOT NULL REFERENCES public.orders(id) ON DELETE CASCADE,
  alpaca_fill_id VARCHAR(100) UNIQUE,
  price DECIMAL(18, 8) NOT NULL,
  qty DECIMAL(18, 8) NOT NULL,
  notional DECIMAL(18, 2) NOT NULL,
  fee DECIMAL(18, 8) DEFAULT 0,
  filled_at TIMESTAMPTZ NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  raw_data JSONB
);

CREATE INDEX idx_fills_order ON public.fills(order_id);

COMMENT ON TABLE public.fills IS 'Order execution fills from Alpaca';

-- ============================================================================
-- SECTION 8: POSITIONS
-- ============================================================================

CREATE TABLE public.positions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  strategy_id UUID NOT NULL REFERENCES public.strategies(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id),
  symbol VARCHAR(20) NOT NULL DEFAULT 'BTC/USD',
  side order_side,
  qty DECIMAL(18, 8) NOT NULL DEFAULT 0,
  avg_entry_price DECIMAL(18, 8),
  current_price DECIMAL(18, 8),
  unrealized_pnl DECIMAL(18, 2) DEFAULT 0,
  realized_pnl DECIMAL(18, 2) DEFAULT 0,
  entry_intent_id UUID REFERENCES public.trade_intents(id),
  entry_order_id UUID REFERENCES public.orders(id),
  entry_at TIMESTAMPTZ,
  stop_loss_price DECIMAL(18, 8),
  take_profit_price DECIMAL(18, 8),
  is_open BOOLEAN NOT NULL DEFAULT false,
  closed_at TIMESTAMPTZ,
  close_reason VARCHAR(50),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(strategy_id, symbol)
);

CREATE INDEX idx_positions_open ON public.positions(strategy_id) WHERE is_open = true;
CREATE INDEX idx_positions_user_open ON public.positions(user_id, is_open) WHERE is_open = true;

COMMENT ON TABLE public.positions IS 'Current and historical positions';

-- ============================================================================
-- SECTION 9: RISK EVENTS
-- ============================================================================

CREATE TABLE public.risk_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  strategy_id UUID REFERENCES public.strategies(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id),
  ts TIMESTAMPTZ NOT NULL DEFAULT now(),
  severity risk_severity NOT NULL,
  code VARCHAR(50) NOT NULL,
  message TEXT,
  details_json JSONB,
  action_taken VARCHAR(50),
  acknowledged BOOLEAN DEFAULT false,
  acknowledged_at TIMESTAMPTZ,
  acknowledged_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_risk_events_strategy ON public.risk_events(strategy_id, ts DESC);
CREATE INDEX idx_risk_events_severity ON public.risk_events(severity, ts DESC) WHERE severity IN ('critical', 'fatal');
CREATE INDEX idx_risk_events_unacked ON public.risk_events(user_id, acknowledged) WHERE acknowledged = false;

COMMENT ON TABLE public.risk_events IS 'Risk events and bumper violations';

-- ============================================================================
-- SECTION 10: RISK BUMPERS STATE
-- ============================================================================

CREATE TABLE public.risk_bumpers_state (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  strategy_id UUID REFERENCES public.strategies(id) ON DELETE CASCADE,
  trading_day DATE NOT NULL DEFAULT CURRENT_DATE,
  daily_loss_usd DECIMAL(18, 2) NOT NULL DEFAULT 0,
  daily_trades_count INTEGER NOT NULL DEFAULT 0,
  cooldown_until TIMESTAMPTZ,
  cooldown_reason VARCHAR(50),
  kill_switch_active BOOLEAN NOT NULL DEFAULT false,
  kill_switch_reason VARCHAR(100),
  kill_switch_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(user_id, strategy_id, trading_day)
);

COMMENT ON TABLE public.risk_bumpers_state IS 'Current state of risk bumpers per user/strategy';

-- ============================================================================
-- SECTION 11: WHALE WATCHLIST
-- ============================================================================

CREATE TABLE public.whale_watchlist (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  address VARCHAR(100) NOT NULL,
  label VARCHAR(100),
  source VARCHAR(50) NOT NULL DEFAULT 'manual',
  score DECIMAL(5, 2) DEFAULT 0,
  rank INTEGER,
  status whale_status NOT NULL DEFAULT 'active',
  notes TEXT,
  tags VARCHAR(50)[],
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  last_activity_at TIMESTAMPTZ,
  UNIQUE(user_id, address)
);

CREATE INDEX idx_whale_watchlist_user ON public.whale_watchlist(user_id, status);

COMMENT ON TABLE public.whale_watchlist IS 'Whale wallet addresses to monitor';

-- ============================================================================
-- SECTION 12: WHALE SNAPSHOTS
-- ============================================================================

CREATE TABLE public.whale_snapshots (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  whale_id UUID NOT NULL REFERENCES public.whale_watchlist(id) ON DELETE CASCADE,
  ts TIMESTAMPTZ NOT NULL DEFAULT now(),
  state_json JSONB NOT NULL,
  delta_json JSONB,
  is_significant BOOLEAN DEFAULT false,
  significance_reason VARCHAR(100),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_whale_snapshots_whale ON public.whale_snapshots(whale_id, ts DESC);
CREATE INDEX idx_whale_snapshots_significant ON public.whale_snapshots(ts DESC) WHERE is_significant = true;

COMMENT ON TABLE public.whale_snapshots IS 'Historical snapshots of whale positions';

-- ============================================================================
-- SECTION 13: WHALE EVENTS
-- ============================================================================

CREATE TABLE public.whale_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  whale_id UUID NOT NULL REFERENCES public.whale_watchlist(id) ON DELETE CASCADE,
  snapshot_id UUID REFERENCES public.whale_snapshots(id),
  ts TIMESTAMPTZ NOT NULL DEFAULT now(),
  event_type VARCHAR(50) NOT NULL,
  symbol VARCHAR(20),
  direction VARCHAR(10),
  details_json JSONB,
  used_as_confirmation BOOLEAN DEFAULT false,
  used_in_signal_id UUID REFERENCES public.signals(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_whale_events_ts ON public.whale_events(ts DESC);

COMMENT ON TABLE public.whale_events IS 'Significant whale trading events';

-- ============================================================================
-- SECTION 14: AGENT TRACES
-- ============================================================================

CREATE TABLE public.agent_traces (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  strategy_id UUID REFERENCES public.strategies(id) ON DELETE CASCADE,
  ts TIMESTAMPTZ NOT NULL DEFAULT now(),
  agent_name VARCHAR(50) NOT NULL,
  intent_id UUID REFERENCES public.trade_intents(id),
  signal_id UUID REFERENCES public.signals(id),
  input_summary TEXT,
  input_ref TEXT,
  output_json JSONB NOT NULL,
  eval_score DECIMAL(3, 2),
  eval_feedback TEXT,
  tokens_input INTEGER,
  tokens_output INTEGER,
  cost_usd DECIMAL(10, 6),
  latency_ms INTEGER,
  model_used VARCHAR(50),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_agent_traces_user ON public.agent_traces(user_id, ts DESC);
CREATE INDEX idx_agent_traces_agent ON public.agent_traces(agent_name, ts DESC);
CREATE INDEX idx_agent_traces_output_gin ON public.agent_traces USING gin(output_json);

COMMENT ON TABLE public.agent_traces IS 'OpenAI agent execution traces';

-- ============================================================================
-- SECTION 15: AGENT PROPOSALS
-- ============================================================================

CREATE TABLE public.agent_proposals (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  strategy_id UUID NOT NULL REFERENCES public.strategies(id) ON DELETE CASCADE,
  agent_trace_id UUID REFERENCES public.agent_traces(id),
  ts TIMESTAMPTZ NOT NULL DEFAULT now(),
  proposal_type VARCHAR(50) NOT NULL,
  title VARCHAR(200) NOT NULL,
  description TEXT,
  current_config JSONB,
  proposed_config JSONB,
  diff_summary TEXT,
  rationale TEXT,
  expected_impact TEXT,
  status VARCHAR(20) NOT NULL DEFAULT 'pending',
  reviewed_at TIMESTAMPTZ,
  reviewed_by UUID REFERENCES auth.users(id),
  review_notes TEXT,
  applied_at TIMESTAMPTZ,
  applied_version_id UUID REFERENCES public.strategy_versions(id),
  expires_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_proposals_pending ON public.agent_proposals(user_id, status) WHERE status = 'pending';
CREATE INDEX idx_proposals_user_pending ON public.agent_proposals(user_id, status) WHERE status = 'pending';

COMMENT ON TABLE public.agent_proposals IS 'AI agent proposals for strategy changes';

-- ============================================================================
-- SECTION 16: MARKET DATA CACHE
-- ============================================================================

CREATE TABLE public.market_data_cache (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  symbol VARCHAR(20) NOT NULL,
  data_type VARCHAR(30) NOT NULL,
  ts TIMESTAMPTZ NOT NULL,
  data_json JSONB NOT NULL,
  source VARCHAR(20) NOT NULL DEFAULT 'hyperliquid',
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  expires_at TIMESTAMPTZ
);

CREATE INDEX idx_market_data_symbol_ts ON public.market_data_cache(symbol, data_type, ts DESC);

COMMENT ON TABLE public.market_data_cache IS 'Cached market data from Hyperliquid';

-- ============================================================================
-- SECTION 17: DAILY METRICS
-- ============================================================================

CREATE TABLE public.daily_metrics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  strategy_id UUID REFERENCES public.strategies(id) ON DELETE CASCADE,
  trading_day DATE NOT NULL,
  total_trades INTEGER NOT NULL DEFAULT 0,
  winning_trades INTEGER NOT NULL DEFAULT 0,
  losing_trades INTEGER NOT NULL DEFAULT 0,
  gross_pnl DECIMAL(18, 2) NOT NULL DEFAULT 0,
  fees_paid DECIMAL(18, 2) NOT NULL DEFAULT 0,
  net_pnl DECIMAL(18, 2) NOT NULL DEFAULT 0,
  max_drawdown DECIMAL(18, 2) DEFAULT 0,
  max_position_size DECIMAL(18, 2) DEFAULT 0,
  signals_generated INTEGER DEFAULT 0,
  signals_executed INTEGER DEFAULT 0,
  signals_rejected INTEGER DEFAULT 0,
  win_rate DECIMAL(5, 2),
  avg_win DECIMAL(18, 2),
  avg_loss DECIMAL(18, 2),
  profit_factor DECIMAL(8, 2),
  sharpe_ratio DECIMAL(8, 4),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(user_id, strategy_id, trading_day)
);

CREATE INDEX idx_daily_metrics_user ON public.daily_metrics(user_id, trading_day DESC);

COMMENT ON TABLE public.daily_metrics IS 'Aggregated daily trading metrics';

-- ============================================================================
-- SECTION 18: SYSTEM CONFIG
-- ============================================================================

CREATE TABLE public.system_config (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  alpaca_paper_enabled BOOLEAN NOT NULL DEFAULT true,
  alpaca_live_enabled BOOLEAN NOT NULL DEFAULT false,
  enable_whale_tracking BOOLEAN NOT NULL DEFAULT true,
  enable_agent_explanations BOOLEAN NOT NULL DEFAULT true,
  enable_agent_proposals BOOLEAN NOT NULL DEFAULT false,
  notify_on_trade BOOLEAN NOT NULL DEFAULT true,
  notify_on_risk_event BOOLEAN NOT NULL DEFAULT true,
  notify_on_proposal BOOLEAN NOT NULL DEFAULT true,
  notification_channels JSONB DEFAULT '{"email": true, "push": false}'::jsonb,
  alpaca_key_ref VARCHAR(100),
  openai_key_ref VARCHAR(100),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(user_id)
);

COMMENT ON TABLE public.system_config IS 'User-level system configuration';

-- ============================================================================
-- SECTION 19: API KEYS
-- ============================================================================

CREATE TABLE public.api_keys (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  provider VARCHAR(30) NOT NULL,
  key_name VARCHAR(100),
  api_key_encrypted TEXT NOT NULL,
  api_secret_encrypted TEXT,
  is_active BOOLEAN NOT NULL DEFAULT true,
  is_valid BOOLEAN,
  last_validated_at TIMESTAMPTZ,
  validation_error TEXT,
  last_used_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(user_id, provider)
);

COMMENT ON TABLE public.api_keys IS 'Encrypted API keys for external services';

-- ============================================================================
-- SECTION 20: AUDIT LOG
-- ============================================================================

CREATE TABLE public.audit_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),
  ts TIMESTAMPTZ NOT NULL DEFAULT now(),
  action VARCHAR(50) NOT NULL,
  entity_type VARCHAR(50) NOT NULL,
  entity_id UUID,
  old_value JSONB,
  new_value JSONB,
  ip_address INET,
  user_agent TEXT,
  source VARCHAR(30) NOT NULL DEFAULT 'user',
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_audit_log_user ON public.audit_log(user_id, ts DESC);
CREATE INDEX idx_audit_log_entity ON public.audit_log(entity_type, entity_id, ts DESC);

COMMENT ON TABLE public.audit_log IS 'Complete audit trail of all actions';
/*
 * ============================================================================
 * TRADINGBOT RLS POLICIES
 * Row Level Security for all trading tables
 * ============================================================================
 */

-- ============================================================================
-- ENABLE RLS ON ALL TABLES
-- ============================================================================

ALTER TABLE public.strategies ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.strategy_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.signals ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.trade_intents ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.fills ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.positions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.risk_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.risk_bumpers_state ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.whale_watchlist ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.whale_snapshots ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.whale_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.agent_traces ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.agent_proposals ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.market_data_cache ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.daily_metrics ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.system_config ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.api_keys ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.audit_log ENABLE ROW LEVEL SECURITY;

-- ============================================================================
-- STRATEGIES POLICIES
-- ============================================================================

CREATE POLICY "strategies_select" ON public.strategies
  FOR SELECT TO authenticated
  USING (auth.uid() = user_id);

CREATE POLICY "strategies_insert" ON public.strategies
  FOR INSERT TO authenticated
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "strategies_update" ON public.strategies
  FOR UPDATE TO authenticated
  USING (auth.uid() = user_id);

CREATE POLICY "strategies_delete" ON public.strategies
  FOR DELETE TO authenticated
  USING (auth.uid() = user_id);

-- ============================================================================
-- STRATEGY VERSIONS POLICIES
-- ============================================================================

CREATE POLICY "strategy_versions_select" ON public.strategy_versions
  FOR SELECT TO authenticated
  USING (EXISTS (
    SELECT 1 FROM public.strategies s
    WHERE s.id = strategy_id AND s.user_id = auth.uid()
  ));

CREATE POLICY "strategy_versions_insert" ON public.strategy_versions
  FOR INSERT TO authenticated
  WITH CHECK (EXISTS (
    SELECT 1 FROM public.strategies s
    WHERE s.id = strategy_id AND s.user_id = auth.uid()
  ));

-- ============================================================================
-- SIGNALS POLICIES
-- ============================================================================

CREATE POLICY "signals_select" ON public.signals
  FOR SELECT TO authenticated
  USING (EXISTS (
    SELECT 1 FROM public.strategies s
    WHERE s.id = strategy_id AND s.user_id = auth.uid()
  ));

-- ============================================================================
-- TRADE INTENTS POLICIES
-- ============================================================================

CREATE POLICY "trade_intents_select" ON public.trade_intents
  FOR SELECT TO authenticated
  USING (EXISTS (
    SELECT 1 FROM public.strategies s
    WHERE s.id = strategy_id AND s.user_id = auth.uid()
  ));

-- ============================================================================
-- ORDERS POLICIES
-- ============================================================================

CREATE POLICY "orders_select" ON public.orders
  FOR SELECT TO authenticated
  USING (EXISTS (
    SELECT 1 FROM public.strategies s
    WHERE s.id = strategy_id AND s.user_id = auth.uid()
  ));

-- ============================================================================
-- FILLS POLICIES
-- ============================================================================

CREATE POLICY "fills_select" ON public.fills
  FOR SELECT TO authenticated
  USING (EXISTS (
    SELECT 1 FROM public.orders o
    JOIN public.strategies s ON s.id = o.strategy_id
    WHERE o.id = order_id AND s.user_id = auth.uid()
  ));

-- ============================================================================
-- POSITIONS POLICIES
-- ============================================================================

CREATE POLICY "positions_select" ON public.positions
  FOR SELECT TO authenticated
  USING (user_id = auth.uid());

-- ============================================================================
-- RISK EVENTS POLICIES
-- ============================================================================

CREATE POLICY "risk_events_select" ON public.risk_events
  FOR SELECT TO authenticated
  USING (
    user_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.strategies s
      WHERE s.id = strategy_id AND s.user_id = auth.uid()
    )
  );

CREATE POLICY "risk_events_update" ON public.risk_events
  FOR UPDATE TO authenticated
  USING (user_id = auth.uid());

-- ============================================================================
-- RISK BUMPERS STATE POLICIES
-- ============================================================================

CREATE POLICY "risk_bumpers_state_select" ON public.risk_bumpers_state
  FOR SELECT TO authenticated
  USING (user_id = auth.uid());

CREATE POLICY "risk_bumpers_state_update" ON public.risk_bumpers_state
  FOR UPDATE TO authenticated
  USING (user_id = auth.uid());

-- ============================================================================
-- WHALE WATCHLIST POLICIES
-- ============================================================================

CREATE POLICY "whale_watchlist_all" ON public.whale_watchlist
  FOR ALL TO authenticated
  USING (user_id = auth.uid())
  WITH CHECK (user_id = auth.uid());

-- ============================================================================
-- WHALE SNAPSHOTS POLICIES
-- ============================================================================

CREATE POLICY "whale_snapshots_select" ON public.whale_snapshots
  FOR SELECT TO authenticated
  USING (EXISTS (
    SELECT 1 FROM public.whale_watchlist w
    WHERE w.id = whale_id AND w.user_id = auth.uid()
  ));

-- ============================================================================
-- WHALE EVENTS POLICIES
-- ============================================================================

CREATE POLICY "whale_events_select" ON public.whale_events
  FOR SELECT TO authenticated
  USING (EXISTS (
    SELECT 1 FROM public.whale_watchlist w
    WHERE w.id = whale_id AND w.user_id = auth.uid()
  ));

-- ============================================================================
-- AGENT TRACES POLICIES
-- ============================================================================

CREATE POLICY "agent_traces_select" ON public.agent_traces
  FOR SELECT TO authenticated
  USING (user_id = auth.uid());

-- ============================================================================
-- AGENT PROPOSALS POLICIES
-- ============================================================================

CREATE POLICY "agent_proposals_select" ON public.agent_proposals
  FOR SELECT TO authenticated
  USING (user_id = auth.uid());

CREATE POLICY "agent_proposals_update" ON public.agent_proposals
  FOR UPDATE TO authenticated
  USING (user_id = auth.uid());

-- ============================================================================
-- MARKET DATA CACHE POLICIES (readable by all authenticated)
-- ============================================================================

CREATE POLICY "market_data_cache_select" ON public.market_data_cache
  FOR SELECT TO authenticated
  USING (true);

-- ============================================================================
-- DAILY METRICS POLICIES
-- ============================================================================

CREATE POLICY "daily_metrics_select" ON public.daily_metrics
  FOR SELECT TO authenticated
  USING (user_id = auth.uid());

-- ============================================================================
-- SYSTEM CONFIG POLICIES
-- ============================================================================

CREATE POLICY "system_config_all" ON public.system_config
  FOR ALL TO authenticated
  USING (user_id = auth.uid())
  WITH CHECK (user_id = auth.uid());

-- ============================================================================
-- API KEYS POLICIES
-- ============================================================================

CREATE POLICY "api_keys_all" ON public.api_keys
  FOR ALL TO authenticated
  USING (user_id = auth.uid())
  WITH CHECK (user_id = auth.uid());

-- ============================================================================
-- AUDIT LOG POLICIES
-- ============================================================================

CREATE POLICY "audit_log_select" ON public.audit_log
  FOR SELECT TO authenticated
  USING (user_id = auth.uid());

-- ============================================================================
-- SERVICE ROLE POLICIES (for backend microservices)
-- ============================================================================

CREATE POLICY "service_role_strategies" ON public.strategies
  FOR ALL TO service_role USING (true) WITH CHECK (true);

CREATE POLICY "service_role_strategy_versions" ON public.strategy_versions
  FOR ALL TO service_role USING (true) WITH CHECK (true);

CREATE POLICY "service_role_signals" ON public.signals
  FOR ALL TO service_role USING (true) WITH CHECK (true);

CREATE POLICY "service_role_trade_intents" ON public.trade_intents
  FOR ALL TO service_role USING (true) WITH CHECK (true);

CREATE POLICY "service_role_orders" ON public.orders
  FOR ALL TO service_role USING (true) WITH CHECK (true);

CREATE POLICY "service_role_fills" ON public.fills
  FOR ALL TO service_role USING (true) WITH CHECK (true);

CREATE POLICY "service_role_positions" ON public.positions
  FOR ALL TO service_role USING (true) WITH CHECK (true);

CREATE POLICY "service_role_risk_events" ON public.risk_events
  FOR ALL TO service_role USING (true) WITH CHECK (true);

CREATE POLICY "service_role_risk_bumpers_state" ON public.risk_bumpers_state
  FOR ALL TO service_role USING (true) WITH CHECK (true);

CREATE POLICY "service_role_whale_watchlist" ON public.whale_watchlist
  FOR ALL TO service_role USING (true) WITH CHECK (true);

CREATE POLICY "service_role_whale_snapshots" ON public.whale_snapshots
  FOR ALL TO service_role USING (true) WITH CHECK (true);

CREATE POLICY "service_role_whale_events" ON public.whale_events
  FOR ALL TO service_role USING (true) WITH CHECK (true);

CREATE POLICY "service_role_agent_traces" ON public.agent_traces
  FOR ALL TO service_role USING (true) WITH CHECK (true);

CREATE POLICY "service_role_agent_proposals" ON public.agent_proposals
  FOR ALL TO service_role USING (true) WITH CHECK (true);

CREATE POLICY "service_role_market_data_cache" ON public.market_data_cache
  FOR ALL TO service_role USING (true) WITH CHECK (true);

CREATE POLICY "service_role_daily_metrics" ON public.daily_metrics
  FOR ALL TO service_role USING (true) WITH CHECK (true);

CREATE POLICY "service_role_system_config" ON public.system_config
  FOR ALL TO service_role USING (true) WITH CHECK (true);

CREATE POLICY "service_role_api_keys" ON public.api_keys
  FOR ALL TO service_role USING (true) WITH CHECK (true);

CREATE POLICY "service_role_audit_log" ON public.audit_log
  FOR ALL TO service_role USING (true) WITH CHECK (true);

-- ============================================================================
-- GRANT PERMISSIONS
-- ============================================================================

-- Grant usage on public schema
GRANT USAGE ON SCHEMA public TO authenticated, service_role;

-- Grant all permissions on trading tables to authenticated and service_role
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO authenticated, service_role;

-- Grant usage on sequences
GRANT USAGE ON ALL SEQUENCES IN SCHEMA public TO authenticated, service_role;
/*
 * ============================================================================
 * TRADINGBOT TRIGGERS & FUNCTIONS
 * Automated database logic for trading operations
 * ============================================================================
 */

-- ============================================================================
-- UTILITY FUNCTIONS
-- ============================================================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Function to set user_id from auth context
CREATE OR REPLACE FUNCTION public.set_user_id()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.user_id IS NULL THEN
    NEW.user_id = auth.uid();
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- UPDATED_AT TRIGGERS
-- ============================================================================

CREATE TRIGGER update_strategies_updated_at
  BEFORE UPDATE ON public.strategies
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_positions_updated_at
  BEFORE UPDATE ON public.positions
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_risk_bumpers_state_updated_at
  BEFORE UPDATE ON public.risk_bumpers_state
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_whale_watchlist_updated_at
  BEFORE UPDATE ON public.whale_watchlist
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_agent_proposals_updated_at
  BEFORE UPDATE ON public.agent_proposals
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_market_data_cache_updated_at
  BEFORE UPDATE ON public.market_data_cache
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_system_config_updated_at
  BEFORE UPDATE ON public.system_config
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_api_keys_updated_at
  BEFORE UPDATE ON public.api_keys
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

-- ============================================================================
-- SET USER_ID TRIGGERS
-- ============================================================================

CREATE TRIGGER set_strategies_user_id
  BEFORE INSERT ON public.strategies
  FOR EACH ROW EXECUTE FUNCTION public.set_user_id();

CREATE TRIGGER set_positions_user_id
  BEFORE INSERT ON public.positions
  FOR EACH ROW EXECUTE FUNCTION public.set_user_id();

CREATE TRIGGER set_risk_events_user_id
  BEFORE INSERT ON public.risk_events
  FOR EACH ROW EXECUTE FUNCTION public.set_user_id();

CREATE TRIGGER set_risk_bumpers_state_user_id
  BEFORE INSERT ON public.risk_bumpers_state
  FOR EACH ROW EXECUTE FUNCTION public.set_user_id();

CREATE TRIGGER set_whale_watchlist_user_id
  BEFORE INSERT ON public.whale_watchlist
  FOR EACH ROW EXECUTE FUNCTION public.set_user_id();

CREATE TRIGGER set_agent_traces_user_id
  BEFORE INSERT ON public.agent_traces
  FOR EACH ROW EXECUTE FUNCTION public.set_user_id();

CREATE TRIGGER set_agent_proposals_user_id
  BEFORE INSERT ON public.agent_proposals
  FOR EACH ROW EXECUTE FUNCTION public.set_user_id();

CREATE TRIGGER set_daily_metrics_user_id
  BEFORE INSERT ON public.daily_metrics
  FOR EACH ROW EXECUTE FUNCTION public.set_user_id();

CREATE TRIGGER set_system_config_user_id
  BEFORE INSERT ON public.system_config
  FOR EACH ROW EXECUTE FUNCTION public.set_user_id();

CREATE TRIGGER set_api_keys_user_id
  BEFORE INSERT ON public.api_keys
  FOR EACH ROW EXECUTE FUNCTION public.set_user_id();

CREATE TRIGGER set_audit_log_user_id
  BEFORE INSERT ON public.audit_log
  FOR EACH ROW EXECUTE FUNCTION public.set_user_id();

-- ============================================================================
-- STRATEGY STATE MACHINE
-- ============================================================================

-- Function to handle strategy state transitions
CREATE OR REPLACE FUNCTION public.handle_strategy_state_transition()
RETURNS TRIGGER AS $$
DECLARE
  valid_transition BOOLEAN := FALSE;
BEGIN
  -- Define valid state transitions
  IF OLD.state = 'idle' AND NEW.state IN ('scanning', 'idle') THEN
    valid_transition := TRUE;
  ELSIF OLD.state = 'scanning' AND NEW.state IN ('signal_detected', 'idle') THEN
    valid_transition := TRUE;
  ELSIF OLD.state = 'signal_detected' AND NEW.state IN ('evaluating', 'idle') THEN
    valid_transition := TRUE;
  ELSIF OLD.state = 'evaluating' AND NEW.state IN ('pending_order', 'idle') THEN
    valid_transition := TRUE;
  ELSIF OLD.state = 'pending_order' AND NEW.state IN ('order_sent', 'idle') THEN
    valid_transition := TRUE;
  ELSIF OLD.state = 'order_sent' AND NEW.state IN ('in_position', 'idle') THEN
    valid_transition := TRUE;
  ELSIF OLD.state = 'in_position' AND NEW.state IN ('monitoring', 'closing', 'idle') THEN
    valid_transition := TRUE;
  ELSIF OLD.state = 'monitoring' AND NEW.state IN ('closing', 'in_position', 'idle') THEN
    valid_transition := TRUE;
  ELSIF OLD.state = 'closing' AND NEW.state IN ('idle') THEN
    valid_transition := TRUE;
  ELSIF OLD.state = 'error' AND NEW.state IN ('idle') THEN
    valid_transition := TRUE;
  ELSIF OLD.state = NEW.state THEN
    valid_transition := TRUE; -- Allow staying in same state
  END IF;

  IF NOT valid_transition THEN
    RAISE EXCEPTION 'Invalid state transition from % to %', OLD.state, NEW.state;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER validate_strategy_state_transition
  BEFORE UPDATE OF state ON public.strategies
  FOR EACH ROW EXECUTE FUNCTION public.handle_strategy_state_transition();

-- ============================================================================
-- SIGNAL PROCESSING
-- ============================================================================

-- Function to auto-create trade intent from signal
CREATE OR REPLACE FUNCTION public.auto_create_trade_intent()
RETURNS TRIGGER AS $$
DECLARE
  strategy_record RECORD;
BEGIN
  -- Get strategy details
  SELECT * INTO strategy_record
  FROM public.strategies
  WHERE id = NEW.strategy_id;

  -- Only create intent if strategy is in paper mode or live mode
  IF strategy_record.mode IN ('paper', 'live') AND NEW.confidence >= 0.7 THEN
    INSERT INTO public.trade_intents (
      strategy_id,
      signal_id,
      symbol,
      side,
      size_usd,
      status,
      created_at
    ) VALUES (
      NEW.strategy_id,
      NEW.id,
      NEW.symbol,
      NEW.side,
      strategy_record.config->>'default_size_usd',
      'pending',
      NOW()
    );

    -- Update strategy state
    UPDATE public.strategies
    SET state = 'signal_detected'
    WHERE id = NEW.strategy_id;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER create_trade_intent_on_signal
  AFTER INSERT ON public.signals
  FOR EACH ROW EXECUTE FUNCTION public.auto_create_trade_intent();

-- ============================================================================
-- ORDER LIFECYCLE
-- ============================================================================

-- Function to update order status and strategy state
CREATE OR REPLACE FUNCTION public.handle_order_status_change()
RETURNS TRIGGER AS $$
BEGIN
  -- Update strategy state based on order status
  IF NEW.status = 'filled' AND OLD.status != 'filled' THEN
    UPDATE public.strategies
    SET state = 'in_position'
    WHERE id = NEW.strategy_id;
  ELSIF NEW.status = 'cancelled' OR NEW.status = 'rejected' THEN
    UPDATE public.strategies
    SET state = 'idle'
    WHERE id = NEW.strategy_id;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER handle_order_status
  AFTER UPDATE OF status ON public.orders
  FOR EACH ROW EXECUTE FUNCTION public.handle_order_status_change();

-- ============================================================================
-- POSITION MANAGEMENT
-- ============================================================================

-- Function to update position on fill
CREATE OR REPLACE FUNCTION public.update_position_on_fill()
RETURNS TRIGGER AS $$
DECLARE
  order_record RECORD;
  strategy_record RECORD;
  existing_position RECORD;
BEGIN
  -- Get order details
  SELECT * INTO order_record FROM public.orders WHERE id = NEW.order_id;
  SELECT * INTO strategy_record FROM public.strategies WHERE id = order_record.strategy_id;

  -- Check for existing position
  SELECT * INTO existing_position
  FROM public.positions
  WHERE user_id = strategy_record.user_id
    AND symbol = order_record.symbol
    AND is_open = TRUE;

  IF existing_position IS NOT NULL THEN
    -- Update existing position
    IF order_record.side = 'buy' THEN
      UPDATE public.positions SET
        quantity = quantity + NEW.quantity,
        avg_entry_price = (avg_entry_price * quantity + NEW.price * NEW.quantity) / (quantity + NEW.quantity),
        updated_at = NOW()
      WHERE id = existing_position.id;
    ELSE
      UPDATE public.positions SET
        quantity = quantity - NEW.quantity,
        realized_pnl = realized_pnl + (NEW.price - avg_entry_price) * NEW.quantity,
        updated_at = NOW()
      WHERE id = existing_position.id;

      -- Close position if quantity reaches zero
      UPDATE public.positions SET
        is_open = FALSE,
        closed_at = NOW()
      WHERE id = existing_position.id AND quantity <= 0;
    END IF;
  ELSE
    -- Create new position
    INSERT INTO public.positions (
      user_id,
      strategy_id,
      symbol,
      side,
      quantity,
      avg_entry_price,
      is_open,
      opened_at
    ) VALUES (
      strategy_record.user_id,
      strategy_record.id,
      order_record.symbol,
      order_record.side,
      NEW.quantity,
      NEW.price,
      TRUE,
      NOW()
    );
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER update_position_on_fill
  AFTER INSERT ON public.fills
  FOR EACH ROW EXECUTE FUNCTION public.update_position_on_fill();

-- ============================================================================
-- RISK MANAGEMENT
-- ============================================================================

-- Function to check risk limits before order
CREATE OR REPLACE FUNCTION public.check_risk_limits()
RETURNS TRIGGER AS $$
DECLARE
  bumpers RECORD;
  daily_loss NUMERIC;
  open_positions INTEGER;
BEGIN
  -- Get risk bumpers state
  SELECT * INTO bumpers
  FROM public.risk_bumpers_state
  WHERE user_id = (SELECT user_id FROM public.strategies WHERE id = NEW.strategy_id);

  IF bumpers IS NOT NULL THEN
    -- Check if trading is halted
    IF bumpers.trading_halted THEN
      -- Log risk event
      INSERT INTO public.risk_events (
        user_id, strategy_id, severity, event_type, message
      ) VALUES (
        bumpers.user_id, NEW.strategy_id, 'critical', 'trading_halted',
        'Order rejected: Trading is halted'
      );
      RAISE EXCEPTION 'Trading is halted due to risk limits';
    END IF;

    -- Check daily loss limit
    SELECT COALESCE(SUM(realized_pnl), 0) INTO daily_loss
    FROM public.positions
    WHERE user_id = bumpers.user_id
      AND closed_at >= CURRENT_DATE;

    IF daily_loss <= -bumpers.max_daily_loss THEN
      -- Halt trading
      UPDATE public.risk_bumpers_state
      SET trading_halted = TRUE
      WHERE user_id = bumpers.user_id;

      INSERT INTO public.risk_events (
        user_id, strategy_id, severity, event_type, message
      ) VALUES (
        bumpers.user_id, NEW.strategy_id, 'critical', 'daily_loss_exceeded',
        FORMAT('Daily loss limit exceeded: $%s', daily_loss)
      );

      RAISE EXCEPTION 'Daily loss limit exceeded';
    END IF;

    -- Check max open positions
    SELECT COUNT(*) INTO open_positions
    FROM public.positions
    WHERE user_id = bumpers.user_id AND is_open = TRUE;

    IF open_positions >= bumpers.max_open_positions THEN
      INSERT INTO public.risk_events (
        user_id, strategy_id, severity, event_type, message
      ) VALUES (
        bumpers.user_id, NEW.strategy_id, 'warning', 'max_positions_reached',
        FORMAT('Max open positions reached: %s', open_positions)
      );
      RAISE EXCEPTION 'Maximum open positions reached';
    END IF;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER check_risk_before_order
  BEFORE INSERT ON public.orders
  FOR EACH ROW EXECUTE FUNCTION public.check_risk_limits();

-- ============================================================================
-- WHALE TRACKING
-- ============================================================================

-- Function to record whale event when significant change detected
CREATE OR REPLACE FUNCTION public.detect_whale_event()
RETURNS TRIGGER AS $$
DECLARE
  previous_snapshot RECORD;
  change_percentage NUMERIC;
  event_type TEXT;
BEGIN
  -- Get previous snapshot
  SELECT * INTO previous_snapshot
  FROM public.whale_snapshots
  WHERE whale_id = NEW.whale_id
  ORDER BY captured_at DESC
  OFFSET 1
  LIMIT 1;

  IF previous_snapshot IS NOT NULL THEN
    -- Calculate change
    IF previous_snapshot.total_usd > 0 THEN
      change_percentage := ((NEW.total_usd - previous_snapshot.total_usd) / previous_snapshot.total_usd) * 100;
    ELSE
      change_percentage := 100;
    END IF;

    -- Determine event type based on change
    IF change_percentage >= 10 THEN
      event_type := 'large_deposit';
    ELSIF change_percentage <= -10 THEN
      event_type := 'large_withdrawal';
    ELSIF ABS(NEW.total_usd - previous_snapshot.total_usd) >= 100000 THEN
      event_type := 'significant_activity';
    ELSE
      RETURN NEW; -- No significant event
    END IF;

    -- Record whale event
    INSERT INTO public.whale_events (
      whale_id,
      event_type,
      description,
      change_usd,
      snapshot_before,
      snapshot_after
    ) VALUES (
      NEW.whale_id,
      event_type,
      FORMAT('%s: %.2f%% change ($%s)', event_type, change_percentage, NEW.total_usd - previous_snapshot.total_usd),
      NEW.total_usd - previous_snapshot.total_usd,
      previous_snapshot.positions,
      NEW.positions
    );
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER detect_whale_event_trigger
  AFTER INSERT ON public.whale_snapshots
  FOR EACH ROW EXECUTE FUNCTION public.detect_whale_event();

-- ============================================================================
-- AUDIT LOGGING
-- ============================================================================

-- Generic audit trigger function
CREATE OR REPLACE FUNCTION public.audit_trigger_function()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.audit_log (
    user_id,
    table_name,
    action,
    old_data,
    new_data
  ) VALUES (
    COALESCE(auth.uid(), '00000000-0000-0000-0000-000000000000'),
    TG_TABLE_NAME,
    TG_OP,
    CASE WHEN TG_OP = 'DELETE' OR TG_OP = 'UPDATE' THEN row_to_json(OLD) ELSE NULL END,
    CASE WHEN TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN row_to_json(NEW) ELSE NULL END
  );

  IF TG_OP = 'DELETE' THEN
    RETURN OLD;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create audit triggers for critical tables
CREATE TRIGGER audit_strategies
  AFTER INSERT OR UPDATE OR DELETE ON public.strategies
  FOR EACH ROW EXECUTE FUNCTION public.audit_trigger_function();

CREATE TRIGGER audit_orders
  AFTER INSERT OR UPDATE OR DELETE ON public.orders
  FOR EACH ROW EXECUTE FUNCTION public.audit_trigger_function();

CREATE TRIGGER audit_positions
  AFTER INSERT OR UPDATE OR DELETE ON public.positions
  FOR EACH ROW EXECUTE FUNCTION public.audit_trigger_function();

CREATE TRIGGER audit_risk_events
  AFTER INSERT ON public.risk_events
  FOR EACH ROW EXECUTE FUNCTION public.audit_trigger_function();

CREATE TRIGGER audit_api_keys
  AFTER INSERT OR UPDATE OR DELETE ON public.api_keys
  FOR EACH ROW EXECUTE FUNCTION public.audit_trigger_function();

-- ============================================================================
-- DAILY METRICS AGGREGATION
-- ============================================================================

-- Function to calculate and store daily metrics
CREATE OR REPLACE FUNCTION public.calculate_daily_metrics(target_user_id UUID, target_date DATE)
RETURNS VOID AS $$
DECLARE
  metrics RECORD;
BEGIN
  -- Calculate metrics for the day
  SELECT
    COUNT(DISTINCT o.id) FILTER (WHERE o.created_at::date = target_date) as total_orders,
    COUNT(DISTINCT o.id) FILTER (WHERE o.status = 'filled' AND o.created_at::date = target_date) as filled_orders,
    COALESCE(SUM(f.quantity * f.price) FILTER (WHERE f.filled_at::date = target_date), 0) as total_volume,
    COALESCE(SUM(p.realized_pnl) FILTER (WHERE p.closed_at::date = target_date), 0) as realized_pnl,
    COUNT(DISTINCT p.id) FILTER (WHERE p.closed_at::date = target_date AND p.realized_pnl > 0) as winning_trades,
    COUNT(DISTINCT p.id) FILTER (WHERE p.closed_at::date = target_date AND p.realized_pnl <= 0) as losing_trades
  INTO metrics
  FROM public.strategies s
  LEFT JOIN public.orders o ON s.id = o.strategy_id
  LEFT JOIN public.fills f ON o.id = f.order_id
  LEFT JOIN public.positions p ON s.id = p.strategy_id
  WHERE s.user_id = target_user_id;

  -- Upsert daily metrics
  INSERT INTO public.daily_metrics (
    user_id,
    date,
    total_pnl,
    total_volume,
    total_trades,
    winning_trades,
    losing_trades,
    fees_paid
  ) VALUES (
    target_user_id,
    target_date,
    metrics.realized_pnl,
    metrics.total_volume,
    metrics.filled_orders,
    metrics.winning_trades,
    metrics.losing_trades,
    0 -- Calculate fees separately
  )
  ON CONFLICT (user_id, date) DO UPDATE SET
    total_pnl = EXCLUDED.total_pnl,
    total_volume = EXCLUDED.total_volume,
    total_trades = EXCLUDED.total_trades,
    winning_trades = EXCLUDED.winning_trades,
    losing_trades = EXCLUDED.losing_trades,
    updated_at = NOW();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- HELPER FUNCTIONS
-- ============================================================================

-- Function to get user's active strategy
CREATE OR REPLACE FUNCTION public.get_active_strategy(p_user_id UUID)
RETURNS TABLE (
  id UUID,
  name TEXT,
  state strategy_state,
  mode strategy_mode
) AS $$
BEGIN
  RETURN QUERY
  SELECT s.id, s.name, s.state, s.mode
  FROM public.strategies s
  WHERE s.user_id = p_user_id
    AND s.is_active = TRUE
  LIMIT 1;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

-- Function to get position summary
CREATE OR REPLACE FUNCTION public.get_position_summary(p_user_id UUID)
RETURNS TABLE (
  total_positions BIGINT,
  total_exposure NUMERIC,
  unrealized_pnl NUMERIC
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    COUNT(*)::BIGINT,
    COALESCE(SUM(quantity * current_price), 0)::NUMERIC,
    COALESCE(SUM(unrealized_pnl), 0)::NUMERIC
  FROM public.positions
  WHERE user_id = p_user_id AND is_open = TRUE;
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

-- Function to initialize user risk bumpers
CREATE OR REPLACE FUNCTION public.initialize_user_risk_bumpers()
RETURNS TRIGGER AS $$
BEGIN
  -- Create default risk bumpers for new user
  INSERT INTO public.risk_bumpers_state (
    user_id,
    max_daily_loss,
    max_position_size,
    max_open_positions,
    trading_halted
  ) VALUES (
    NEW.id,
    1000.00, -- Default $1000 daily loss limit
    5000.00, -- Default $5000 max position
    5,       -- Default 5 max open positions
    FALSE
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Note: This trigger should be created on auth.users table
-- For now, we'll handle this in the application layer

/*
 * ============================================================================
 * TRADINGBOT REALTIME CONFIGURATION
 * Enable Supabase Realtime for trading tables
 * ============================================================================
 */

-- ============================================================================
-- ENABLE REALTIME PUBLICATION
-- ============================================================================

-- Create publication for realtime if not exists
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_publication WHERE pubname = 'supabase_realtime') THEN
    CREATE PUBLICATION supabase_realtime;
  END IF;
END
$$;

-- ============================================================================
-- ADD TABLES TO REALTIME PUBLICATION
-- ============================================================================

-- Core trading tables - high priority for real-time updates
ALTER PUBLICATION supabase_realtime ADD TABLE public.strategies;
ALTER PUBLICATION supabase_realtime ADD TABLE public.signals;
ALTER PUBLICATION supabase_realtime ADD TABLE public.trade_intents;
ALTER PUBLICATION supabase_realtime ADD TABLE public.orders;
ALTER PUBLICATION supabase_realtime ADD TABLE public.fills;
ALTER PUBLICATION supabase_realtime ADD TABLE public.positions;

-- Risk management tables
ALTER PUBLICATION supabase_realtime ADD TABLE public.risk_events;
ALTER PUBLICATION supabase_realtime ADD TABLE public.risk_bumpers_state;

-- Whale tracking tables
ALTER PUBLICATION supabase_realtime ADD TABLE public.whale_events;
ALTER PUBLICATION supabase_realtime ADD TABLE public.whale_snapshots;

-- AI agent tables
ALTER PUBLICATION supabase_realtime ADD TABLE public.agent_traces;
ALTER PUBLICATION supabase_realtime ADD TABLE public.agent_proposals;

-- Market data cache (for real-time price updates)
ALTER PUBLICATION supabase_realtime ADD TABLE public.market_data_cache;

-- ============================================================================
-- REPLICA IDENTITY CONFIGURATION
-- Required for UPDATE and DELETE events in Realtime
-- ============================================================================

-- Set REPLICA IDENTITY to FULL for tables that need complete row data
ALTER TABLE public.strategies REPLICA IDENTITY FULL;
ALTER TABLE public.signals REPLICA IDENTITY FULL;
ALTER TABLE public.trade_intents REPLICA IDENTITY FULL;
ALTER TABLE public.orders REPLICA IDENTITY FULL;
ALTER TABLE public.fills REPLICA IDENTITY FULL;
ALTER TABLE public.positions REPLICA IDENTITY FULL;
ALTER TABLE public.risk_events REPLICA IDENTITY FULL;
ALTER TABLE public.risk_bumpers_state REPLICA IDENTITY FULL;
ALTER TABLE public.whale_events REPLICA IDENTITY FULL;
ALTER TABLE public.whale_snapshots REPLICA IDENTITY FULL;
ALTER TABLE public.agent_traces REPLICA IDENTITY FULL;
ALTER TABLE public.agent_proposals REPLICA IDENTITY FULL;
ALTER TABLE public.market_data_cache REPLICA IDENTITY FULL;

-- ============================================================================
-- REALTIME BROADCAST CHANNELS
-- Configuration for custom broadcast channels
-- ============================================================================

-- Note: Broadcast channels are configured at the application level
-- The following channels will be used:

-- 1. trading:signals - Signal detection broadcasts
-- 2. trading:orders - Order status updates
-- 3. trading:positions - Position changes
-- 4. risk:events - Risk event notifications
-- 5. whale:events - Whale activity alerts
-- 6. agent:proposals - AI agent proposals for approval

-- ============================================================================
-- PRESENCE CHANNELS
-- For tracking active users and sessions
-- ============================================================================

-- Note: Presence channels are also configured at the application level
-- The following presence channels will be used:

-- 1. presence:workbench - Track active workbench users
-- 2. presence:trading - Track users with active trading sessions

-- ============================================================================
-- COMMENTS FOR DOCUMENTATION
-- ============================================================================

COMMENT ON PUBLICATION supabase_realtime IS 'Publication for Supabase Realtime - includes all trading tables for live updates';

